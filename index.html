<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SupNice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation; /* 防止移动端双击缩放 */
        }
        
        body {
            width: 640px;
            height: 1008px;
            margin: 0 auto;
            overflow: hidden;
            position: relative;
            background-color: #f0f0f0;
        }
        
        .page {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            background-color: #fff;
        }
        
        .page.active {
            display: block;
        }
        
        .next-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 30px solid #333;
            cursor: pointer;
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateX(-50%) translateY(0);
            }
            40% {
                transform: translateX(-50%) translateY(-20px);
            }
            60% {
                transform: translateX(-50%) translateY(-10px);
            }
        }
        
        #game-page {
            background-color: #e0f7fa;
        }
        
        .shape {
            position: absolute;
            border-radius: 50%;
            opacity: 0.7;
            cursor: pointer;
        }
        
        .small-shape {
            position: absolute;
        }
        
        .trapezoid {
            border-bottom: 30px solid #ff9800;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            height: 0;
            width: 50px;
        }
        
        .square {
            width: 40px;
            height: 40px;
            background-color: #4caf50;
        }
        
        .diamond {
            width: 40px;
            height: 40px;
            background-color: #2196f3;
            transform: rotate(45deg);
            transform-origin: 50% 50%;
        }
        
        .red { background-color: #f44336; }
        .blue { background-color: #2196f3; }
        .green { background-color: #4caf50; }
    </style>
</head>
<body>
    <!-- 空白页面容器，用于动态生成5个空白页 -->
    <div id="blank-pages">
        <!-- 动态生成5个空白页面 -->
    </div>
    
    <!-- 游戏页面，背景色为浅蓝绿色 -->
    <div id="game-page" class="page">
        <h1 style="text-align: center; margin-top: 20px;">SupNice 小游戏</h1>
        <div id="game-container" style="width: 100%; height: 90%; position: relative;"></div>
        <div id="game-complete" style="display: none; text-align: center; margin-top: 40px;">
            <h2>恭喜完成!</h2>
            <button id="next-level" style="padding: 10px 20px; margin-top: 20px;">下一页</button>
        </div>
    </div>
    
    <!-- 结果页面，游戏完成后显示 -->
    <div id="result-page" class="page">
        <h1 style="text-align: center; margin-top: 200px;">游戏结束!</h1>
        <p style="text-align: center; margin-top: 50px;">感谢参与 SupNice 小游戏</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 创建5个空白页面
            const blankPagesContainer = document.getElementById('blank-pages');
            for (let i = 0; i < 5; i++) {
                const page = document.createElement('div'); // 创建页面元素
                page.className = 'page'; // 添加页面样式类
                page.id = `blank-page-${i}`; // 设置唯一ID
                
                // 为前4页添加跳转到下一页的按钮
                if (i < 4) {
                    const nextBtn = document.createElement('div'); // 创建按钮元素
                    nextBtn.className = 'next-btn'; // 添加按钮样式类
                    nextBtn.addEventListener('click', function() { // 点击事件：切换到下一页
                        page.classList.remove('active'); // 移除当前页激活状态
                        document.getElementById(`blank-page-${i + 1}`).classList.add('active'); // 激活下一页
                    });
                    page.appendChild(nextBtn); // 将按钮添加到页面
                } else {
                    // 第5页的按钮跳转到游戏页面并初始化游戏
                    const nextBtn = document.createElement('div');
                    nextBtn.className = 'next-btn';
                    nextBtn.addEventListener('click', function() {
                        page.classList.remove('active'); // 隐藏当前页
                        document.getElementById('game-page').classList.add('active'); // 显示游戏页
                        initGame(); // 初始化游戏逻辑
                    });
                    page.appendChild(nextBtn);
                }
                
                blankPagesContainer.appendChild(page); // 将页面添加到容器
            }
            
            // 显示第一页
            document.getElementById('blank-page-0').classList.add('active');
            
            // 游戏核心变量定义
            let gameContainer; // 游戏容器DOM元素
            let largeCircles = []; // 存储大型圆形的数组
            let smallShapes = []; // 存储小型形状的数组
            let isDragging = false; // 拖拽状态标记
            let currentCircle = null; // 当前拖拽的圆形
            let velocity = { x: 0, y: 0 }; // 滑动速度向量
            
            // 初始化游戏场景
            function initGame() {
                gameContainer = document.getElementById('game-container'); // 获取游戏容器
                gameContainer.innerHTML = ''; // 清空容器内容
                
                // 创建3个大型圆形（红、蓝、绿）
                createLargeCircle(100, 200, 'red');
                createLargeCircle(250, 400, 'blue');
                createLargeCircle(400, 600, 'green');
                
                // 随机生成3-5个小型形状（梯形/正方形/菱形）
                const shapeCount = Math.floor(Math.random() * 3) + 3; // 3-5个
                for (let i = 0; i < shapeCount; i++) {
                    const shapeType = ['trapezoid', 'square', 'diamond'][Math.floor(Math.random() * 3)];
                    createSmallShape(shapeType);
                }
                
                // 绑定触摸事件（移动端）
                gameContainer.addEventListener('touchstart', handleTouchStart);
                gameContainer.addEventListener('touchmove', handleTouchMove);
                gameContainer.addEventListener('touchend', handleTouchEnd);
                
                // 绑定鼠标事件（电脑端）
                gameContainer.addEventListener('mousedown', handleMouseDown);
                gameContainer.addEventListener('mousemove', handleMouseMove);
                gameContainer.addEventListener('mouseup', handleMouseUp);
                gameContainer.addEventListener('mouseleave', handleMouseUp); // 鼠标离开视为松开
                
                // 隐藏游戏完成提示
                document.getElementById('game-complete').style.display = 'none';
                
                // 绑定下一页按钮事件
                document.getElementById('next-level').addEventListener('click', function() {
                    document.getElementById('game-page').classList.remove('active');
                    document.getElementById('result-page').classList.add('active');
                });
            }
            
            // 创建大型圆形函数
            function createLargeCircle(x, y, color) {
                const circle = document.createElement('div'); // 创建圆形元素
                circle.className = `shape ${color}`; // 添加样式类
                circle.style.width = '80px'; // 设置宽度
                circle.style.height = '80px'; // 设置高度
                circle.style.left = `${x}px`; // 设置左侧位置
                circle.style.top = `${y}px`; // 设置顶部位置
                circle.dataset.color = color; // 存储颜色数据
                circle.dataset.type = 'large'; // 存储类型数据
                
                // 存储圆形数据到数组（用于逻辑处理）
                largeCircles.push({
                    element: circle, // DOM元素
                    x: x, // x坐标
                    y: y, // y坐标
                    radius: 40, // 半径
                    color: color, // 颜色
                    isDragging: false // 拖拽状态
                });
                
                gameContainer.appendChild(circle); // 添加到游戏容器
            }
            
            // 创建小型形状函数
            function createSmallShape(type) {
                const shape = document.createElement('div'); // 创建形状元素
                shape.className = `small-shape ${type}`; // 添加样式类
                
                // 随机生成位置（避开边缘）
                const x = Math.floor(Math.random() * (gameContainer.offsetWidth - 50));
                const y = Math.floor(Math.random() * (gameContainer.offsetHeight - 50));
                
                shape.style.left = `${x}px`; // 设置左侧位置
                shape.style.top = `${y}px`; // 设置顶部位置
                shape.dataset.type = type; // 存储类型数据
                
                // 存储形状数据到数组
                smallShapes.push({
                    element: shape, // DOM元素
                    x: x, // x坐标
                    y: y, // y坐标
                    type: type // 类型
                });
                
                gameContainer.appendChild(shape); // 添加到游戏容器
            }
            
            // 触摸开始事件处理（移动端）
            function handleTouchStart(e) {
                e.preventDefault(); // 阻止默认触摸行为
                const touch = e.touches[0]; // 获取第一个触摸点
                const touchX = touch.clientX; // 触摸点X坐标
                const touchY = touch.clientY; // 触摸点Y坐标
                
                // 检测触摸是否在圆形上
                for (let i = 0; i < largeCircles.length; i++) {
                    const circle = largeCircles[i];
                    const rect = circle.element.getBoundingClientRect(); // 获取圆形边界框
                    
                    // 计算触摸点到圆心的距离
                    const dx = touchX - (rect.left + circle.radius);
                    const dy = touchY - (rect.top + circle.radius);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= circle.radius) { // 距离小于等于半径则视为触摸到
                        isDragging = true; // 标记为拖拽状态
                        currentCircle = circle; // 设置当前拖拽的圆形
                        currentCircle.startX = touchX; // 记录开始位置
                        currentCircle.startY = touchY;
                        currentCircle.lastX = touchX; // 记录上一次位置
                        currentCircle.lastY = touchY;
                        velocity = { x: 0, y: 0 }; // 重置速度
                        break;
                    }
                }
            }
            
            // 鼠标按下事件处理（电脑端）
            function handleMouseDown(e) {
                e.preventDefault(); // 阻止默认鼠标行为
                const mouseX = e.clientX; // 鼠标X坐标
                const mouseY = e.clientY; // 鼠标Y坐标
                
                // 检测鼠标是否在圆形上（逻辑同触摸检测）
                for (let i = 0; i < largeCircles.length; i++) {
                    const circle = largeCircles[i];
                    const rect = circle.element.getBoundingClientRect();
                    
                    const dx = mouseX - (rect.left + circle.radius);
                    const dy = mouseY - (rect.top + circle.radius);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= circle.radius) {
                        isDragging = true;
                        currentCircle = circle;
                        currentCircle.startX = mouseX;
                        currentCircle.startY = mouseY;
                        currentCircle.lastX = mouseX;
                        currentCircle.lastY = mouseY;
                        velocity = { x: 0, y: 0 };
                        break;
                    }
                }
            }
            
            // 触摸移动事件处理（移动端）
            function handleTouchMove(e) {
                if (!isDragging) return; // 非拖拽状态直接返回
                e.preventDefault(); // 阻止触摸移动默认行为
                
                const touch = e.touches[0]; // 获取当前触摸点
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                // 计算移动距离
                const dx = touchX - currentCircle.lastX;
                const dy = touchY - currentCircle.lastY;
                
                // 更新圆形位置（包含边界检测）
                updateCirclePosition(dx, dy);
                
                // 计算滑动速度
                velocity.x = dx;
                velocity.y = dy;
                
                // 更新上一次位置
                currentCircle.lastX = touchX;
                currentCircle.lastY = touchY;
                
                // 检测碰撞
                checkCollisions(currentCircle);
            }
            
            // 鼠标移动事件处理（电脑端）
            function handleMouseMove(e) {
                if (!isDragging) return; // 非拖拽状态直接返回
                e.preventDefault(); // 阻止鼠标移动默认行为
                
                const mouseX = e.clientX; // 当前鼠标X坐标
                const mouseY = e.clientY; // 当前鼠标Y坐标
                
                // 计算移动距离
                const dx = mouseX - currentCircle.lastX;
                const dy = mouseY - currentCircle.lastY;
                
                // 更新圆形位置（包含边界检测）
                updateCirclePosition(dx, dy);
                
                // 计算滑动速度
                velocity.x = dx;
                velocity.y = dy;
                
                // 更新上一次位置
                currentCircle.lastX = mouseX;
                currentCircle.lastY = mouseY;
                
                // 检测碰撞
                checkCollisions(currentCircle);
            }
            
            // 更新圆形位置的通用函数（含边界检测）
            function updateCirclePosition(dx, dy) {
                currentCircle.x += dx; // 更新x坐标
                currentCircle.y += dy; // 更新y坐标
                
                // 左边界检测
                if (currentCircle.x < 0) currentCircle.x = 0;
                // 右边界检测（考虑圆形半径）
                if (currentCircle.x > gameContainer.offsetWidth - currentCircle.radius * 2) {
                    currentCircle.x = gameContainer.offsetWidth - currentCircle.radius * 2;
                }
                // 上边界检测
                if (currentCircle.y < 0) currentCircle.y = 0;
                // 下边界检测（考虑圆形半径）
                if (currentCircle.y > gameContainer.offsetHeight - currentCircle.radius * 2) {
                    currentCircle.y = gameContainer.offsetHeight - currentCircle.radius * 2;
                }
                
                // 更新DOM元素位置
                currentCircle.element.style.left = `${currentCircle.x}px`;
                currentCircle.element.style.top = `${currentCircle.y}px`;
            }
            
            // 触摸结束事件处理（移动端）
            function handleTouchEnd(e) {
                if (!isDragging) return; // 非拖拽状态直接返回
                e.preventDefault(); // 阻止触摸结束默认行为
                
                isDragging = false; // 清除拖拽状态
                currentCircle = null; // 清空当前圆形
                
                // 应用滑动效果
                applySlideEffect();
            }
            
            // 鼠标松开事件处理（电脑端）
            function handleMouseUp(e) {
                if (!isDragging) return; // 非拖拽状态直接返回
                e.preventDefault(); // 阻止鼠标松开默认行为
                
                isDragging = false;
                currentCircle = null;
                
                // 应用滑动效果
                applySlideEffect();
            }
            
            // 应用滑动效果（松手后的惯性移动）
            function applySlideEffect() {
                // 速度过小则停止滑动
                if (Math.abs(velocity.x) < 0.5 && Math.abs(velocity.y) < 0.5) return;
                
                // 速度衰减（模拟摩擦力）
                velocity.x *= 0.95;
                velocity.y *= 0.95;
                
                // 遍历所有圆形更新位置（确保圆形间不互相影响）
                for (let i = 0; i < largeCircles.length; i++) {
                    const circle = largeCircles[i];
                    
                    // 仅更新当前拖拽相关的速度（避免多圆形互相影响）
                    circle.x += velocity.x;
                    circle.y += velocity.y;
                    
                    // 边界检查与反弹
                    let hitBoundary = false;
                    if (circle.x < 0) {
                        circle.x = 0;
                        velocity.x = -velocity.x * 0.7; // 反弹并减速
                        hitBoundary = true;
